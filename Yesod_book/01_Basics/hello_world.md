
# Hello World in Yesod

This covers the first part of the ["Basics" chapter of the Yesod book](https://www.yesodweb.com/book/basics).

## The program

```haskell
{-# LANGUAGE OverloadedStrings     #-}
{-# LANGUAGE QuasiQuotes           #-}
{-# LANGUAGE TemplateHaskell       #-}
{-# LANGUAGE TypeFamilies          #-}
import Yesod

data HelloWorld = HelloWorld

mkYesod "HelloWorld" [parseRoutes|
/ HomeR GET
|]

instance Yesod HelloWorld

getHomeR :: Handler Html
getHomeR = defaultLayout [whamlet|Hello World!|]

main :: IO ()
main = warp 3000 HelloWorld
```
## Analysis of the program

According to the [“Resources and Statements” section](https://www.w3.org/TR/rdf11-concepts/#resources-and-statements) of the World Wide Web Consortium (W3C) primer on the Resource Description Framework (RDF),

> Any \[URL or URI\] denotes something in the world (the "universe of discourse"). These things are called **resources.**

`HomeR` is a **resource** (hence the "R").

We have created a datatype called `HelloWorld` and made it an instance of the `Yesod` typeclass. Then, we passed the *string* `"HelloWorld"` to `mkYesod`.

`mkYesod` is a Template Haskell function. To see the code it generates, use `ddump-splices`.

### The code generated by `mkYesod`
```haskell
instance RenderRoute HelloWorld where
    data Route HelloWorld = HomeR
        deriving (Show, Eq, Read)
    renderRoute HomeR = ([], [])

instance ParseRoute HelloWorld where
    parseRoute ([], _) = Just HomeR
    parseRoute _       = Nothing

instance YesodDispatch HelloWorld where
    yesodDispatch env req =
        yesodRunner handler env mroute req
      where
        mroute = parseRoute (pathInfo req, textQueryString req)
        handler =
            case mroute of
                Nothing -> notFound
                Just HomeR ->
                    case requestMethod req of
                        "GET" -> getHomeR
                        _     -> badMethod

type Handler = HandlerT HelloWorld IO
```

 * `HelloWorld` is made an instance of the `RenderRoute` typeclass.
	 - The type `Route HelloWorld` has data constructor `HomeR`.
	 - The function `renderRoute` takes a route and spits out path segments and query string parameters.
 * `HelloWorld` is also an instance of the `ParseRoutes` typeclass.
	 - `parseRoute` is the inverse of `renderRoute`. It takes path segments and query string parameters and returns a route.
	 - We use Template Haskell so that `renderRoute` and `parseRoute` have the correct inverse behavior.
 * `HelloWorld` is also an instance of `YesodDispatch`.
	 - Think “911 dispatch”. `YesodDispatch` has functions that route requests to the appropriate handler.

### Handlers
To define how `HomeR` responds to `GET` requests, write a **handler function:** `getHomeR`.

Uses of handler functions:

 - Render pages
 - Process user input
 - Query databases
 - Create responses (e.g. for a REST API)

Yesod convention: lowercase method name (`get`) ++ name of resource with R (`HomeR`) = handler function name (`getHomeR`)

The `defaultLayout` function wraps inputs it receives in the site’s template.

 - By default, adds standard HTML elements: `<!DOCTYPE>`, `<html>`, `<head>`, and `<body>` tags.
 - Customizable

### Foundation

Every Yesod app has a **foundation datatype**. In this case, it was `HelloWorld`.

The foundation datatype:

 - Has the same name as the app (usually)
 - Is an instance of the `Yesod` typeclass

Things that might be stored in a foundation datatype:

 - Database connection pool (apparently this is a collection of “remembered” database connections to speed things up)
 - 

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTM2MjY3ODQxMiwtODYyODgwMjMsMjEyMT
I1NDM0MSwyMDA4MTQzMzgyLDE5NzY2MDc3NjMsLTkyNDI4MDA1
Nyw0MzMyMjY2MDEsMTM2MzczMTE2LDU2MjA5MTEwMSwtMTA2ND
I5ODA0M119
-->