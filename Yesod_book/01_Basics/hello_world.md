
# Hello World in Yesod

This covers the first part of the ["Basics" chapter of the Yesod book](https://www.yesodweb.com/book/basics).

## The program ##

```haskell
{-# LANGUAGE OverloadedStrings     #-}
{-# LANGUAGE QuasiQuotes           #-}
{-# LANGUAGE TemplateHaskell       #-}
{-# LANGUAGE TypeFamilies          #-}
import Yesod

data HelloWorld = HelloWorld

mkYesod "HelloWorld" [parseRoutes|
/ HomeR GET
|]

instance Yesod HelloWorld

getHomeR :: Handler Html
getHomeR = defaultLayout [whamlet|Hello World!|]

main :: IO ()
main = warp 3000 HelloWorld
```
## Analysis of the program

According to the [“Resources and Statements” section](https://www.w3.org/TR/rdf11-concepts/#resources-and-statements) of the World Wide Web Consortium (W3C) primer on the Resource Description Framework (RDF),

> Any \[URL or URI\] denotes something in the world (the "universe of discourse"). These things are called **resources.**

`HomeR` is a **resource** (hence the "R").

We have created a datatype called `HelloWorld` and made it an instance of the `Yesod` typeclass. Then, we passed the *string* `"HelloWorld"` to `mkYesod`.

`mkYesod` is a Template Haskell function. To see the code it generates, use `ddump-splices`.

### The code generated by `mkYesod`
```haskell
instance RenderRoute HelloWorld where
    data Route HelloWorld = HomeR
        deriving (Show, Eq, Read)
    renderRoute HomeR = ([], [])

instance ParseRoute HelloWorld where
	{- If the first arg is the empty list, `parseRoutes`
	outputs `HomeR`, the home resource. -}
    parseRoute ([], _) = Just HomeR
    parseRoute _       = Nothing

instance YesodDispatch HelloWorld where
    yesodDispatch env req =
        yesodRunner handler env mroute req
      where
        mroute = parseRoute (pathInfo req, textQueryString req)
        handler =
            case mroute of
                Nothing -> notFound
                Just HomeR ->
                    case requestMethod req of
                        "GET" -> getHomeR
                        _     -> badMethod

type Handler = HandlerT HelloWorld IO
```

 * `HelloWorld` is made an instance of the `RenderRoute` typeclass.
	 - The type `Route HelloWorld` has data constructor `HomeR`.
	 - The function `renderRoute` takes a route and spits out path segments and query string parameters.
 * `HelloWorld` is also an instance of the `ParseRoutes` typeclass.
	 - `parseRoute` is the inverse of `renderRoute`. It takes path segments and query string parameters and returns a route.
	 - We use Template Haskell so that `renderRoute` and `parseRoute` have the correct inverse behavior.
 * `HelloWorld` is also an instance of `YesodDispatch`.
	 - Think “911 dispatch”. `YesodDispatch` has functions that route requests to the appropriate handler.
	 - 
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTk3NjYwNzc2MywtOTI0MjgwMDU3LDQzMz
IyNjYwMSwxMzYzNzMxMTYsNTYyMDkxMTAxLC0xMDY0Mjk4MDQz
XX0=
-->